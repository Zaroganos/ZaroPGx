  # In order to manually generate your docker compose file, use:
  # 'mv docker-compose.yml.example docker-compose.yml' and adjust the parameters.

services:  
  # ~~~~~~~~~~MAIN APP~~~~~~~~~~
  # Main FastAPI Application with Web UI, API, and supporting services
  # ~~~~~~~~~~MAIN APP~~~~~~~~~~
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: pgx_app
    restart: unless-stopped
    depends_on:
      - db
      - pharmcat
      - gatk-api
      - pypgx
      - kroki
    environment:
      - DATABASE_URL=postgresql+psycopg://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}
      - SECRET_KEY=${SECRET_KEY}
      - PHARMCAT_API_URL=http://pharmcat:5000
      - PHARMCAT_JAR_PATH=/pharmcat/pharmcat.jar
      - INCLUDE_PHARMCAT_HTML=true
      - INCLUDE_PHARMCAT_JSON=true
      - INCLUDE_PHARMCAT_TSV=true
      - GATK_API_URL=http://gatk-api:5000
      - PYPGX_API_URL=http://pypgx:5000
      - GENOME_DOWNLOADER_API_URL=http://genome-downloader:5050
      - USE_NEXTFLOW=${USE_NEXTFLOW}
      - NEXTFLOW_RUNNER_URL=${NEXTFLOW_RUNNER_URL}
      - FHIR_SERVER_URL=http://fhir-server:8080/fhir
      - KROKI_URL=http://kroki:8000
      - SOURCE_URL=${SOURCE_URL}
      - PYTHONPATH=/app
      - WORKFLOW_API_BASE=http://app:8000/api/v1
      - PYTHONDONTWRITEBYTECODE=1
      - LOG_LEVEL=${LOG_LEVEL:-DEBUG}
      - EXECSUM_USE_TSV=true
    volumes:
      - ./:/app
      - ./data:/data
      - ./scripts:/scripts:ro
    ports:
      - "${BIND_ADDRESS:-8765}:8000"
    healthcheck:
      test: ["CMD", "echo", "Healthcheck disabled for debugging"]
      interval: 10s
      timeout: 5s
      retries: 1
    networks:
      - pgx-network
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
  
  
  # PostgreSQL Database
  db:
    image: postgres:17
    container_name: pgx_db
    restart: unless-stopped
    environment:
      POSTGRES_USER: cpic_user
      POSTGRES_PASSWORD: test123
      POSTGRES_DB: cpic_db
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./db/init:/docker-entrypoint-initdb.d
    ports:
      - "5444:5432"
    healthcheck:
      test: ["CMD", "echo", "Healthcheck disabled for debugging"]
      interval: 10s
      timeout: 5s
      retries: 1
    networks:
      - pgx-network


  # Reference genome downloader service
  genome-downloader:
    build:
      context: ./docker/genome-downloader
      dockerfile: Dockerfile.downloader
    container_name: pgx_genome_downloader
    volumes:
      - ./reference:/reference
    environment:
      - DOWNLOAD_ON_STARTUP=true
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5050/health"]
      interval: 10s
      timeout: 5s
      retries: 3
    ports:
      - "5050:5050"
    networks:
      - pgx-network


  # PharmCAT Service Wrapper - combines JAR and API
  pharmcat:
    build:
      context: .
      dockerfile: docker/pharmcat/Dockerfile
      args:
        PHARMCAT_VERSION: ${PHARMCAT_VERSION:-3.0.1}
    container_name: pgx_pharmcat
    restart: unless-stopped
    volumes:
      - ./data:/data
      # Mount reference files where PharmCAT expects them
      - pharmcat-references:/pharmcat
    ports:
      - "5001:5000"  # FastAPI port
    environment:
      - DATA_DIR=/data
      - JAVA_OPTS=-Xmx4g
      - PHARMCAT_LOG_LEVEL=DEBUG
      - PHARMCAT_REFERENCE_DIR=/pharmcat
      - PHARMCAT_TEE=true
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      - pgx-network


  # HAPI FHIR Server for EHR/PHR/EMR integration
  fhir-server:
    image: hapiproject/hapi:latest
    container_name: pgx_fhir_server
    restart: unless-stopped
    ports:
      - "8090:8080"
    environment:
      - hapi.fhir.allow_external_references=true
      - hapi.fhir.allow_multiple_delete=true
      - hapi.fhir.reuse_cached_search_results_millis=60000
      - spring.datasource.url=jdbc:postgresql://db:5432/cpic_db?currentSchema=fhir
      - spring.datasource.username=cpic_user
      - spring.datasource.password=test123
      - spring.datasource.driverClassName=org.postgresql.Driver
      - spring.jpa.properties.hibernate.dialect=ca.uhn.fhir.jpa.model.dialect.HapiFhirPostgresDialect
      - spring.jpa.hibernate.ddl-auto=update
      - spring.jpa.properties.hibernate.default_schema=fhir
      - hapi.fhir.jpa.database_schema=update
      - hapi.fhir.jpa.auto_create_tables=true
      - hapi.fhir.jpa.database_schema_auto_create=true
      - hapi.fhir.jpa.database_schema_auto_validate=true
      - hapi.fhir.jpa.disable_temporary_table_creation=true
      - spring.jpa.open-in-view=false
      - hapi.fhir.max_page_size=50
      - hapi.fhir.default_page_size=20
      - hapi.fhir.subscription.resthook_enabled=true
      - hapi.fhir.subscription.websocket_enabled=false
      - JAVA_OPTS=-Djava.io.tmpdir=/tmp -Xmx2g
      - SPRING_DATASOURCE_INITIALIZATION_MODE=always
    depends_on:
      db:
        condition: service_started
    volumes:
      - ./data/fhir-data:/data/hapi
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/fhir/metadata"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - pgx-network


  # GATK Service Wrapper
  gatk-api:
    build:
      context: .
      dockerfile: docker/gatk-api/Dockerfile.gatk-api
    container_name: pgx_gatk_api
    restart: unless-stopped
    depends_on:
      genome-downloader:
        condition: service_healthy
    volumes:
      - ./data:/data
      - ./reference:/reference
    environment:
      - REFERENCE_DIR=/reference
      - DATA_DIR=/data
      - MAX_MEMORY=20g
      - PYTHONPATH=/app
      - UVICORN_RELOAD_EXCLUDES=".git/*,.venv/*"
    ports:
      - "5002:5000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 40s
    networks:
      - pgx-network
    deploy:
      resources:
        limits:
          memory: 28G


  # PyPGx Service Wrapper
  pypgx:
    build:
      context: .
      dockerfile: docker/pypgx/Dockerfile.pypgx
    container_name: pgx_pypgx
    restart: unless-stopped
    depends_on:
      genome-downloader:
        condition: service_healthy
    volumes:
      - ./data:/data
      - ./reference:/reference
      - ./config:/app/config
    environment:
      - DATA_DIR=/data
      - REFERENCE_DIR=/reference
      - PYPGX_MEMORY_LIMIT=7G
      - PYPGX_MAX_PARALLEL_GENES=8
      - PYPGX_BATCH_SIZE=4
      - PYPGX_PHARMCAT_PREFERENCE=${PYPGX_PHARMCAT_PREFERENCE:-auto}  # auto|pypgx|pharmcat
    ports:
      - "5053:5000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 40s
    networks:
      - pgx-network
    deploy:
      resources:
        limits:
          memory: 20G
        reservations:
          memory: 7G


  # OptiType Service (CLI container, no HTTP wrapper) 
  # CURRENTLY UNUSED, USING HLATYPING INSTEAD
  # FEEL FREE TO DELETE THIS SECTION ON YOUR MACHINE
  # optitype:
  #   image: smithnickh/optitype:v2.0
  #   container_name: pgx_optitype
  #   restart: unless-stopped
  #   # Keep the container running so we can exec CLI commands into it from other services
  #   command: ["tail", "-f", "/dev/null"]
  #   volumes:
  #     - ./data:/data
  #   healthcheck:
  #     test: ["CMD-SHELL", "command -v OptiTypePipeline.py >/dev/null 2>&1 || test -f /OptiTypePipeline.py || test -f /opt/OptiType/OptiTypePipeline.py"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 40s
  #   networks:
  #     - pgx-network


  # nf-core/hlatyping Wrapper Service (HTTP API running Nextflow)
  # OptiType v1.3.5 inside
  hlatyping:
    build:
      context: .
      dockerfile: docker/hlatyping/Dockerfile.hlatyping
    container_name: pgx_hlatyping
    restart: unless-stopped
    environment:
      - DATA_DIR=/data
      - HLATYPING_PROFILE=docker
      - HLATYPING_PIPELINE_VERSION=2.1.0
      - NXF_OPTS=-Xms1g -Xmx8g
    volumes:
      - ./data:/data
      # Mount host docker socket so Nextflow can launch docker tasks with -profile docker
      - /var/run/docker.sock:/var/run/docker.sock
      # Optional Nextflow cache directory to persist between runs
      - ./data/nextflow:/opt/nextflow
    ports:
      - "5060:5000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 40s
    networks:
      - pgx-network


  # Kroki Service for diagram rendering (Mermaid, Graphviz, etc.)
  kroki:
    image: yuzutech/kroki:latest
    container_name: pgx_kroki
    restart: unless-stopped
    depends_on:
      - mermaid
    ports:
      - "8001:8000"
    environment:
      - KROKI_SAFE_MODE=false
      - KROKI_MAX_DURATION=30000
      - KROKI_MAX_SIZE=10485760
      - KROKI_LOG_LEVEL=INFO
      - KROKI_MERMAID_HOST=mermaid
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
      - pgx-network


  mermaid:
    image: yuzutech/kroki-mermaid:latest
    container_name: pgx_kroki_mermaid
    command: ["--no-sandbox", "--disable-dev-shm-usage", "--disable-software-rasterizer", "--disable-gpu", "--disable-features=GlobalMediaControls"]
    expose:
      - "8002"
    environment:
      - CHROME_ARGS=--disable-dbus --no-sandbox --disable-dev-shm-usage --disable-gpu
    networks:
      - pgx-network


  # Nextflow executor for orchestrating the ZaroPGx pharmacogenomic pipeline
  nextflow:
    build:
      context: .
      dockerfile: docker/nextflow/Dockerfile.nextflow
    container_name: pgx_nextflow
    restart: unless-stopped
    environment:
      - NXF_HOME=/opt/nextflow
      - NXF_OPTS=-Xms1g -Xmx4g
    volumes:
      - ./:/workspace
      - ./data:/data
      - ./reference:/reference
      - ./data/nextflow:/opt/nextflow
      # Allow Nextflow to launch docker tasks when using -profile docker
      - /var/run/docker.sock:/var/run/docker.sock
    working_dir: /workspace
    ports:
      - "5055:5055"
    networks:
      - pgx-network


  # Sphinx Documentation service (live reload)
  docs:
    build:
      context: .
      dockerfile: docker/docs/Dockerfile.docs
    container_name: pgx_docs
    restart: unless-stopped
    volumes:
      - ./docs:/docs
    ports:
      - "5070:8000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - pgx-network


volumes:
  pgdata:
    driver: local
  fhir-data:
    driver: local
  pharmcat-references:
    driver: local


networks:
  pgx-network:
    name: pgx-network
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: ${NETWORK_SUBNET:-172.28.0.0/16}