<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZaroPGx - Pharmacogenomics Platform</title>
    <!-- Favicon references -->
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="shortcut icon" href="/static/favicon.png">
    <link rel="apple-touch-icon" href="/static/favicon.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Add Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <script>
        (function() {
            try {
                const storedTheme = localStorage.getItem('zpgx-theme');
                const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = storedTheme || (prefersDark ? 'dark' : 'light');
                document.documentElement.setAttribute('data-bs-theme', theme);
            } catch (e) {
                document.documentElement.setAttribute('data-bs-theme', 'light');
            }
        })();
    </script>
    <style>
        :root {
            color-scheme: light;
            --header-bg: #0066cc;
            --header-text: #ffffff;
            --footer-bg: #f8f9fa;
            --card-header-bg: #0066cc;
            --card-header-text: #ffffff;
        }
        [data-bs-theme='dark'] {
            color-scheme: dark;
            --header-bg: #0b3d91;
            --header-text: #e6e6e6;
            --footer-bg: #0f172a;
            --card-header-bg: #0b3d91;
            --card-header-text: #e6e6e6;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding-top: 20px;
            background-color: var(--bs-body-bg);
            color: var(--bs-body-color);
        }
        .header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 1.25rem 1rem;
            margin-bottom: 2rem;
            border-radius: 0.5rem;
        }
        .header-inner {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 1rem;
        }
        .header-icon-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-color: rgba(255, 255, 255, 0.65) !important;
            color: var(--header-text) !important;
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }
        .header-icon-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .card {
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .card-header {
            background-color: var(--card-header-bg);
            color: var(--card-header-text);
            font-weight: bold;
        }
        .footer {
            margin-top: 3rem;
            padding: 1.5rem 0;
            background-color: var(--footer-bg);
            text-align: center;
        }
        .stage-indicator {
            position: relative;
            padding: 0 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            z-index: 1;
        }
        
        .stage-indicator:hover {
            background-color: rgba(0, 123, 255, 0.1);
            border-color: rgba(0, 123, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .stage-indicator.disabled {
            cursor: not-allowed;
        }
        
        .stage-indicator.disabled:hover {
            background-color: rgba(108, 117, 125, 0.1);
            border-color: rgba(108, 117, 125, 0.3);
            transform: none;
        }
        
        /* Stage popup tooltip */
        .stage-popup {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px;
            min-width: 280px;
            max-width: 320px;
            z-index: 9999;
            margin-top: 8px;
            display: none;
        }
        
        .stage-popup::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid white;
        }
        
        .stage-popup::after {
            content: '';
            position: absolute;
            top: -9px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 9px solid #dee2e6;
        }
        
        .stage-popup h6 {
            margin: 0 0 8px 0;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
        }
        
        .stage-popup p {
            margin: 0 0 12px 0;
            color: #6c757d;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .stage-popup .toggle-section {
            border-top: 1px solid #e9ecef;
            padding-top: 12px;
            margin-top: 12px;
        }
        
        .stage-popup .toggle-button {
            width: 100%;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            background: #f8f9fa;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .stage-popup .toggle-button:hover {
            background: #e9ecef;
        }
        
        .stage-popup .toggle-button.enabled {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .stage-popup .toggle-button.disabled {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        /* Simplified Stage Indicator System - Uses Bootstrap classes with minimal custom additions */
        
        /* Running state - add pulsing animation to Bootstrap success color */
        .stage-indicator.text-success i {
            animation: pulse-running 2s infinite;
        }
        
        /* Failed state - add pulsing animation to Bootstrap danger color */
        .stage-indicator.text-danger i {
            animation: pulse-error 1s infinite;
        }
        
        /* Disabled state - only fade the icon and main text, NEVER the tooltip */
        .stage-indicator.disabled .mb-1 i,
        .stage-indicator.disabled > span {
            opacity: 0.3 !important;
        }
        
        /* Ensure tooltip content is NEVER faded, regardless of parent state */
        .stage-indicator .stage-popup,
        .stage-indicator .stage-popup * {
            opacity: 1 !important;
        }
        
        /* Connection lost state - dimmed and pulsing red */
        .stage-indicator.connection-lost {
            opacity: 0.5;
            animation: connection-lost-pulse 2s infinite;
        }
        
        @keyframes connection-lost-pulse {
            0% { 
                opacity: 0.5; 
                filter: hue-rotate(0deg);
            }
            50% { 
                opacity: 0.3; 
                filter: hue-rotate(180deg);
            }
            100% { 
                opacity: 0.5; 
                filter: hue-rotate(0deg);
            }
        }

        /* Ensure all stage icons have consistent size */
        .stage-indicator i {
            font-size: 1.2rem;
            margin-bottom: 0.25rem;
        }
        
        /* Enhanced pulsing animations */
        @keyframes pulse-running {
            0% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.05);
            }
            100% { 
                opacity: 1; 
                transform: scale(1);
            }
        }
        
        @keyframes pulse-error {
            0% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.6; 
                transform: scale(1.1);
            }
            100% { 
                opacity: 1; 
                transform: scale(1);
            }
        }
        
        /* Legacy support - these classes are now handled by JavaScript state management */
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Header display area styling */
        #headerDisplay {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.125);
        }

        #headerContent {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        #headerContent .table {
            margin-bottom: 0;
            font-size: 0.875rem;
        }

        #headerContent .table td {
            word-break: break-all;
            max-width: 200px;
        }

        #headerContent .alert {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #headerContent .alert ul {
            margin-bottom: 0;
            padding-left: 1.5rem;
        }

        #headerContent .alert li {
            word-break: break-word;
            margin-bottom: 0.25rem;
        }


        /* Dark mode support for inner cards */
        [data-bs-theme='dark'] #headerContent .card.bg-light {
            background-color: #374151 !important;
            border-color: rgba(255, 255, 255, 0.125);
        }

        [data-bs-theme='dark'] #headerContent .text-muted {
            color: #9ca3af !important;
        }
        
        /* Dark mode support for log panel body */
        [data-bs-theme='dark'] #logPanel .card-body {
            background-color: #374151 !important;
            color: #e5e7eb !important;
        }
        
        /* Dark theme support - Bootstrap handles this automatically, just need custom animations */
        [data-bs-theme='dark'] .stage-indicator.text-success i {
            animation: pulse-running 2s infinite;
        }
        
        [data-bs-theme='dark'] .stage-indicator.text-danger i {
            animation: pulse-error 1s infinite;
        }

        /* Responsive design for header display */
        @media (max-width: 768px) {
            #headerContent .table td {
                max-width: 120px;
                font-size: 0.8rem;
            }

            #headerContent .row > div {
                margin-bottom: 1rem;
            }
        }
        
        /* Custom progress bar animation to ensure stripes are always visible */
        #progressBar, #upload-progress-bar {
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
            transition: width 0.1s ease-out;
        }
        
        /* Only animate when Bootstrap animation classes are present */
        #progressBar.progress-bar-animated, #upload-progress-bar.progress-bar-animated {
            animation: progress-bar-stripes 1s linear infinite;
        }
        
        @keyframes progress-bar-stripes {
            0% {
                background-position: 1rem 0;
            }
            100% {
                background-position: 0 0;
            }
        }
        
        /* Cancellation visual feedback styles */
        .progress-bar-cancelling {
            animation: none !important; /* Stop the stripe animation */
            background-color: #dc3545 !important; /* Red color for cancellation */
            transition: width 2s ease-in-out !important; /* Smooth reverse animation */
        }
        
        .stage-indicator-cancelling-active {
            color: #dc3545 !important; /* Red color for active stage during cancellation */
            animation: none !important; /* Stop pulsing */
        }
        
        .stage-indicator-cancelling-analyze {
            color: #198754 !important; /* Green color for analyze stage during cancellation */
            animation: pulse 1s infinite !important; /* Keep pulsing green */
        }
        
        .progress-container-cancelling {
            opacity: 1;
            transition: opacity 0.5s ease-out 2s; /* Fade out after progress bar reaches 0 */
        }
        
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-inner">
                <div class="header-left d-flex">
                    <a href="/" class="btn btn-outline-light header-icon-btn" aria-label="Home" title="Home">
                        <i class="bi bi-house-door-fill"></i>
                    </a>
                </div>
                <div class="header-center text-center">
                    <h1 class="mb-0">ZaroPGx</h1>
                    <p class="lead mb-0">Pharmacogenomic Analysis Platform</p>
                </div>
                <div class="header-right d-flex justify-content-end">
                    <button id="themeToggle" class="btn btn-outline-light header-icon-btn" aria-label="Toggle theme" title="Toggle theme">
                        <i id="themeIcon" class="bi bi-moon-stars-fill"></i>
                    </button>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-8 offset-md-2">
                <!-- Login Form (shown by default) -->
                <div id="loginForm" class="card mb-4 d-none">
                    <div class="card-header">Login</div>
                    <div class="card-body">
                        <form id="authForm">
                            <div class="mb-3">
                                <label for="username" class="form-label">Username</label>
                                <input type="text" class="form-control" id="username" name="username" required>
                            </div>
                            <div class="mb-3">
                                <label for="password" class="form-label">Password</label>
                                <input type="password" class="form-control" id="password" name="password" required>
                            </div>
                            <button type="submit" class="btn btn-primary">Login</button>
                        </form>
                    </div>
                </div>

                <!-- Main Content (hidden until logged in) -->
                <div id="mainContent">
                <!-- Display messages if any -->
                {% if message %}
                <div class="alert {{ 'alert-success' if success else 'alert-danger' }}" role="alert">
                    {{ message }}
                    {% if success and report_id %}
                    <div class="mt-3">
                        <p>Your report is ready!</p>
                        <a href="{{ report_pdf }}" target="_blank" class="btn btn-primary">View PDF Report</a>
                        <a href="{{ report_html }}" target="_blank" class="btn btn-info">View Interactive Report</a>
                    </div>
                    {% endif %}
                </div>
                {% endif %}

                <!-- Service status alert - shown only if services are down -->
                {% if service_alert %}
                <div class="alert alert-danger alert-dismissible fade show" role="alert">
                    <div class="d-flex align-items-center">
                        <div>
                            <strong><i class="bi bi-exclamation-triangle-fill me-2"></i>Service Issue Detected</strong>
                            <span> - {{ service_alert }}</span>
                        </div>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
                {% endif %}

                <div class="card">
                    <div class="card-header">Upload Genomic File for Analysis</div>
                    <div class="card-body">
                            <form action="/upload/genomic-data" method="post" enctype="multipart/form-data" id="uploadForm">
                            <div class="mb-3">
                                <label for="genomicFile" class="form-label">Genomic File(s)</label>
                                    <input class="form-control" type="file" id="genomicFile" name="files" accept=".vcf,.vcf.gz,.bam,.sam,.cram,.fastq,.fastq.gz,.fq,.fq.gz,.txt,.csv,.zip,.bai,.crai,.csi,.tbi,.idx" multiple required>
                                    <div class="form-text">Upload a VCF datafile for pharmacogenomic analysis (currently only GRCh38/hg38 supported.) An index file may be included. Formats FASTQ, BAM, SAM, CRAM, and GRCh37/hg19 VCFs are in testing. Support for BED, 23andMe, and other TXT formats is in development.</div>
                            </div>
                                
                            <div class="mb-3">
                                    <label for="sampleIdentifier" class="form-label">Sample Identifier (Optional)</label>
                                    <input type="text" class="form-control" id="sampleIdentifier" name="sample_identifier" placeholder="Enter a sample identifier">
                                </div>


                                
                                
                            
                            <!-- Stage indicators (always visible) -->
                            <div class="d-flex justify-content-between small mb-3" style="overflow: visible;">
                                <!-- Upload Stage -->
                                <div id="stageUpload" class="stage-indicator text-center text-muted" data-stage="upload" data-toggleable="false">
                                    <div class="mb-1"><i class="bi bi-cloud-upload"></i></div>
                                    <span>Upload</span>
                                    <div class="stage-popup">
                                        <h6>File Upload</h6>
                                        <p>Receive and route the uploaded genomic data file(s) for analysis.</p>
                                    </div>
                                </div>
                                
                                <!-- Analysis Stage -->
                                <div id="stageAnalysis" class="stage-indicator text-center text-muted" data-stage="analysis" data-toggleable="false">
                                    <div class="mb-1"><i class="bi bi-search"></i></div>
                                    <span>Analysis</span>
                                    <div class="stage-popup">
                                        <h6>File Analysis</h6>
                                        <p>Inspect and analyze the uploaded file(s), to determine reference, sequencing type, quality, and content. Prepare workflow for the job.</p>
                                    </div>
                                </div>
                                
                                <!-- OptiType Stage -->
                                <div id="stageHLA" class="stage-indicator text-center text-muted" data-stage="hla" data-toggleable="true" data-enabled="true">
                                    <div class="mb-1"><i class="bi bi-virus2"></i></div>
                                    <span>OptiType</span>
                                    <div class="stage-popup">
                                        <h6>OptiType HLA Typing</h6>
                                        <p>Perform Human Leukocyte Antigen (HLA) typing with hlatyping, using OptiType. Can be computationally intensive.</p>
                                        <div class="toggle-section">
                                            <button class="toggle-button enabled" data-stage="hla">✓ Enabled</button>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- GATK Stage -->
                                <div id="stageGATK" class="stage-indicator text-center text-muted" data-stage="gatk" data-toggleable="true" data-enabled="true">
                                    <div class="mb-1"><i class="bi bi-cpu"></i></div>
                                    <span>GATK</span>
                                    <div class="stage-popup">
                                        <h6>GATK Processing</h6>
                                        <p>Genome Analysis Toolkit (GATK) includes functions for filetype conversion and other manipulations. Can be computationally intensive.</p>
                                        <div class="toggle-section">
                                            <button class="toggle-button enabled" data-stage="gatk">✓ Enabled</button>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- PyPGx Stage -->
                                <div id="stagePyPGx" class="stage-indicator text-center text-muted" data-stage="pypgx" data-toggleable="true" data-enabled="true">
                                    <div class="mb-1"><i class="bi bi-star"></i></div>
                                    <span>PyPGx</span>
                                    <div class="stage-popup">
                                        <h6>PyPGx Star Allele Calling</h6>
                                        <p>Call pharmacogenomic star alleles using PyPGx. Additional functions include certain filetype conversions and more.</p>
                                        <div class="toggle-section">
                                            <button class="toggle-button enabled" data-stage="pypgx">✓ Enabled</button>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- PharmCAT Stage -->
                                <div id="stagePharmcat" class="stage-indicator text-center text-muted" data-stage="pharmcat" data-toggleable="false">
                                    <div class="mb-1"><i class="bi bi-capsule"></i></div>
                                    <span>PharmCAT</span>
                                    <div class="stage-popup">
                                        <h6>PharmCAT Analysis</h6>
                                        <p>Call variants and match phenotypes with recommendations. Generate a pharmacogenomic report.</p>
                                    </div>
                                </div>
                                
                                <!-- Report Stage -->
                                <div id="stageReport" class="stage-indicator text-center text-muted" data-stage="report" data-toggleable="true" data-enabled="true">
                                    <div class="mb-1"><i class="bi bi-file-earmark-text"></i></div>
                                    <span>Report</span>
                                    <div class="stage-popup">
                                        <h6>Custom Reports</h6>
                                        <p>Generate custom formatted reports with visualizations. When disabled, only PharmCAT's native report is provided.</p>
                                        <div class="toggle-section">
                                            <button class="toggle-button enabled" data-stage="report">✓ Enabled</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Multi-stage progress bar (hidden by default) -->
                            <div id="progressContainer" class="mb-3 d-none">
                                <div class="d-flex justify-content-between align-items-center mb-2">
                                    <label class="form-label mb-0" id="progressLabel">Progress</label>
                                </div>
                                <div class="progress mb-2" style="height: 25px;">
                                    <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-info" 
                                         role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" 
                                         style="width: 0%;">
                                        0%
                                    </div>
                                </div>
                                <div id="progressStatus" class="form-text mb-2 fw-bold">Preparing...</div>
                                
                                <!-- Detailed log panel (initially collapsed) -->
                                <div class="card">
                                    <div class="card-header p-2" role="button" data-bs-toggle="collapse" data-bs-target="#logPanel">
                                        <small>Processing Log <i class="bi bi-chevron-down float-end"></i></small>
                                    </div>
                                    <div id="logPanel" class="collapse">
                                        <div id="logMessages" class="card-body p-2 small" style="max-height: 150px; overflow-y: auto; font-family: monospace;">
                                            <!-- Log messages will appear here -->
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Nextflow Process Details (initially collapsed) -->
                                <div id="nextflowProcessPanel" class="card d-none">
                                    <div class="card-header bg-info text-white p-2" role="button" data-bs-toggle="collapse" data-bs-target="#nextflowProcessDetails">
                                        <small class="text-white">
                                            <i class="bi bi-diagram-3 me-1"></i>
                                            Nextflow Process Details 
                                            <span id="nextflowProcessCount" class="badge bg-light text-dark ms-2">0 processes</span>
                                            <i class="bi bi-chevron-down float-end"></i>
                                        </small>
                                    </div>
                                    <div id="nextflowProcessDetails" class="collapse">
                                        <div class="card-body p-2">
                                            <div id="nextflowProcessList" class="small">
                                                <!-- Process details will appear here -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="d-flex gap-2 justify-content-between">
                                <div class="d-flex gap-2">
                                    <button type="submit" class="btn btn-primary" id="uploadButton">Upload</button>

                                    <!-- View Header button -->
                                    <button type="button" class="btn btn-info" id="viewHeaderButton" onclick="viewHeader()">
                                        <i class="bi bi-eye"></i> View Header
                                    </button>

                                    <!-- Demo button for PharmCAT example -->
                                    <button type="button" class="btn btn-secondary" id="demoButton" onclick="runPharmCatDemo()" title="Run Demo with PharmCAT VCF">
                                        <i class="bi bi-play-fill"></i> Run Demo
                                    </button>
                                </div>

                                <!-- Cancel button (hidden by default, shown during progress) -->
                                <button type="button" class="btn btn-danger d-none" id="cancelButton" onclick="cancelJobMonitoring()" title="Cancel job monitoring">
                                    <i class="bi bi-x-circle"></i> Cancel
                                </button>
                            </div>
                        </form>
                    </div>
                </div>

                <!-- Analysis Results Container (placed above Workflow Details) -->
                <div id="analysisResults" class="card mt-4 d-none">
                    <div class="card-header">Analysis Results</div>
                    <div class="card-body">
                        <!-- Results will be displayed here -->
                    </div>
                </div>

                <!-- Workflow Details Panel (moved below progress/logs & buttons) -->
                <div id="workflowAnalysisPanel" class="card mt-3 d-none">
                    <div class="card-header p-2" role="button" data-bs-toggle="collapse" data-bs-target="#workflowAnalysisCollapse">
                        <div class="d-flex align-items-center justify-content-between">
                            <span>
                                <i class="bi bi-clipboard-data me-2"></i>
                                Workflow Details
                            </span>
                            <i class="bi bi-chevron-down"></i>
                        </div>
                    </div>
                    <div id="workflowAnalysisCollapse" class="collapse show">
                        <div class="card-body">
                            <!-- File & Workflow Details (hidden until populated) -->
                            <div id="fileAnalysis" class="mb-2">
                                <div class="row g-3">
                                    <!-- Left column: File details (top) + Info alerts (bottom) -->
                                    <div class="col-12 col-lg-6 d-flex flex-column">
                                        <div class="card flex-grow-1">
                                            <div class="card-body">
                                                <div id="fileTypeInfo" class="mb-2"></div>
                                                <div id="vcfInfo" class="mb-2 d-none"></div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Right column: Planned workflow (top) + Warnings (bottom) -->
                                    <div class="col-12 col-lg-6 d-flex flex-column">
                                        <div class="card flex-grow-1">
                                            <div class="card-body">
                                                <div id="plannedWorkflowInfo" class="mb-2"></div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Alerts Row: ensure info and warning boxes start at the same vertical position -->
                                    <div class="col-12 col-lg-6">
                                        <div id="infoAlertsLeft" class="mt-1"></div>
                                    </div>
                                    <div class="col-12 col-lg-6">
                                        <div id="warnings" class="alert alert-warning d-none mt-1"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                    <!-- Header Display Area -->
                    <div id="headerDisplay" class="card mt-4 d-none">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">
                                <i class="bi bi-file-earmark-text me-2"></i>
                                File Header Information
                            </h5>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="viewHeader()" title="Hide header information">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                        <div class="card-body">
                            <div id="headerContent" class="container-fluid">
                                <!-- Header content will be displayed here -->
                            </div>
                        </div>
                    </div>

                <div class="row align-items-stretch">
                    <div class="col-md-6 d-flex">
                        <div class="card h-100 w-100">
                            <div class="card-header">ZaroPgx Documentation</div>
                            <div class="card-body d-flex flex-column h-100">
                                <p class="mb-0">ZaroPGx is a free and open source, easily self-hostable individual pharmacogenomic
                                    analysis system which attempts to create the most accurate and complete reports possible 
                                    with a given genomic datafile.<br><br>                         
                                    For detailed information, see the software documentation and access the API reference.</p>
                                <div class="mt-auto d-flex gap-2">
                                    <a href="/documentation/" class="btn btn-secondary">Documentation</a>
                                    <a href="/api-reference" class="btn btn-outline-secondary">API Reference</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mt-3 mt-md-0 d-flex">
                        <div class="card h-100 w-100">
                            <div class="card-header">About PharmCAT</div>
                            <div class="card-body d-flex flex-column h-100">
                                <p>This platform uses PharmCAT to generate recommendations based on institutional guidelines.<br>
                                    PharmCAT is now part of the ClinPGx project, which includes CPIC and PharmGKB.
                                    PharmCAT includes outside calls from <a href="https://nf-co.re/hlatyping/">hlatyping(OptiType)</a> and <a href="https://pypgx.readthedocs.io/en/latest/readme.html">PyPGx</a> when available.
                                    For a full list of software comprising ZaroPGx, please see the documentation.
                                </p>
                                <div class="mt-auto d-flex gap-2">
                                    <a href="https://pharmcat.org/" target="_blank" class="btn btn-secondary">Learn More</a>
                                    <a href="https://www.clinpgx.org/" target="_blank" class="btn btn-outline-secondary">ClinPGx</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer small">
            <p class="mb-1">&copy; 2024-{{ current_year }} {{ author_name or 'Zaromics Initiative' }}</p>
            <p class="mb-1">This program is licensed under the <a href="{{ license_url }}" target="_blank" rel="noopener">{{ license_name }}</a>.</p>
            <p class="mb-0">Source code: <a href="{{ source_url }}" target="_blank" rel="noopener">{{ source_url }}</a>. Provided without warranty; see license for details.</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Add JavaScript file for upload progress tracking -->
    <script src="/static/js/GenomeDownloadProgress.js"></script>
    
    <!-- Workflow Monitoring Scripts -->
    <script src="/static/js/workflow-monitor.js"></script>
    
    <!-- Add JavaScript for real progress tracking using WebSocket -->
    <script>
        // Theme toggle
        document.addEventListener('DOMContentLoaded', function() {
            const themeToggle = document.getElementById('themeToggle');
            const themeIcon = document.getElementById('themeIcon');
            function setTheme(theme) {
                document.documentElement.setAttribute('data-bs-theme', theme);
                try { localStorage.setItem('zpgx-theme', theme); } catch (e) {}
                if (themeIcon) {
                    themeIcon.className = theme === 'dark' ? 'bi bi-sun-fill' : 'bi bi-moon-stars-fill';
                }
                if (themeToggle) {
                    const label = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
                    themeToggle.setAttribute('aria-label', label);
                    themeToggle.title = label;
                }
            }
            const stored = (function(){ try { return localStorage.getItem('zpgx-theme'); } catch(e) { return null; } })();
            const initial = stored || document.documentElement.getAttribute('data-bs-theme') || 'light';
            setTheme(initial);
            if (themeToggle) {
                themeToggle.addEventListener('click', function() {
                    const current = document.documentElement.getAttribute('data-bs-theme') || 'light';
                    setTheme(current === 'dark' ? 'light' : 'dark');
                });
            }
            if (window.matchMedia) {
                try {
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
                        const explicit = (function(){ try { return localStorage.getItem('zpgx-theme'); } catch(e) { return null; } })();
                        if (!explicit) {
                            setTheme(e.matches ? 'dark' : 'light');
                        }
                    });
                } catch (e) {}
            }
        });

        // Define accessToken globally so it can be accessed by all functions
        let accessToken = null; // Will be set on page load
        
        document.addEventListener('DOMContentLoaded', function() {
            const loginForm = document.getElementById('loginForm');
            const mainContent = document.getElementById('mainContent');
            const authForm = document.getElementById('authForm');
            
            /* 
             * TEMPORARY CHANGE: Skip authentication for development
             * This bypasses login completely during development.
             * Remove this code before production deployment.
             */
            // No token is set - we'll make requests without authentication
            loginForm.classList.add('d-none');
            mainContent.classList.remove('d-none');
            
            // Original authentication code is preserved below for future use
            
            // Function to show main content
            function showMainContent() {
                loginForm.classList.add('d-none');
                mainContent.classList.remove('d-none');
            }

            // Update the file upload handler to work without auth token
            const form = document.getElementById('uploadForm');
            const fileInput = document.getElementById('genomicFile');
            const fileAnalysis = document.getElementById('fileAnalysis');
            const fileTypeInfo = document.getElementById('fileTypeInfo');
            const vcfInfo = document.getElementById('vcfInfo');
            const workflowInfo = document.getElementById('workflowInfo');
            const warnings = document.getElementById('warnings');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressStatus = document.getElementById('progressStatus');
            const logMessages = document.getElementById('logMessages');

            // Function to add log message - make it globally available
            window.addLogMessage = function(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `text-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                logMessages.appendChild(logEntry);
                logMessages.scrollTop = logMessages.scrollHeight;
            };

            // Build a consistent, aesthetically rendered planned workflow section
            window.buildPlannedWorkflowHTML = function(options) {
                const opts = options || {};
                const wf = opts.workflow || {};
                const fileType = (opts.fileType || '').toString().toLowerCase();

                const steps = [];
                // Always begin with analysis (header inspection)
                steps.push({ name: 'Analysis (Header Inspection)', icon: 'bi-search' });

                // GATK needed for certain formats or explicit flag
                const needsGatk = !!wf.needs_gatk || !!wf.needs_alignment || !!wf.needs_conversion || ['sam', 'cram', 'fastq'].includes(fileType);
                if (needsGatk) {
                    steps.push({ name: 'GATK Processing', icon: 'bi-cpu' });
                }

                // PyPGx is generally part of the pipeline unless explicitly disabled
                const needsPyPgx = (typeof wf.needs_pypgx === 'boolean') ? wf.needs_pypgx : true;
                if (needsPyPgx) {
                    steps.push({ name: 'PyPGx Star Allele Calling', icon: 'bi-star' });
                }

                // Include bam2vcf conversion for alignment-based inputs or explicit flag
                const needsBam2Vcf = !!wf.needs_pypgx_bam2vcf || ['bam', 'cram', 'sam'].includes(fileType);
                if (needsBam2Vcf) {
                    steps.push({ name: 'PyPGx BAM→VCF Conversion', icon: 'bi-shuffle' });
                }

                // PharmCAT and Report are core terminal steps
                steps.push({ name: 'PharmCAT Analysis', icon: 'bi-capsule' });
                steps.push({ name: 'Report Generation', icon: 'bi-file-earmark-text' });

                let html = `
                    <h6 class="card-title d-flex align-items-center mb-2">
                        <i class="bi bi-diagram-3 me-2 text-primary"></i>
                        Planned Workflow
                    </h6>
                    <ul class="list-group">
                `;
                steps.forEach(step => {
                    html += `
                        <li class="list-group-item d-flex align-items-center">
                            <i class="bi ${step.icon} me-2"></i>
                            <span>${step.name}</span>
                        </li>
                    `;
                });
                html += `</ul>`;
                return html;
            };

            // Function to update file analysis display - make it globally available
            window.updateFileAnalysis = function(analysis) {
                // Ensure the panel is visible and expanded
                const workflowPanel = document.getElementById('workflowAnalysisPanel');
                const workflowCollapse = document.getElementById('workflowAnalysisCollapse');
                if (workflowPanel) {
                    workflowPanel.classList.remove('d-none');
                }
                if (workflowCollapse && !workflowCollapse.classList.contains('show')) {
                    const collapseInstance = bootstrap.Collapse.getOrCreateInstance(workflowCollapse, { toggle: false });
                    collapseInstance.show();
                }

                fileAnalysis.classList.remove('d-none');
                
                // Normalize incoming shapes: prefer analysis.analysis_info (backend UploadResponse)
                const afi = analysis.analysis_info || {};
                const wf = analysis.workflow || {};

                // Update file type info
                fileTypeInfo.innerHTML = `
                    <strong>File Type:</strong> ${(analysis.file_type || afi.file_type) || 'Unknown'}<br>
                    <strong>Compressed:</strong> ${afi.is_compressed ? 'Yes' : 'No'}<br>
                    <strong>Has Index:</strong> ${afi.has_index ? 'Yes' : 'No'}
                `;

                // Update VCF info if available
                if (afi.vcf_info) {
                    vcfInfo.classList.remove('d-none');
                    vcfInfo.innerHTML = `
                        <strong>Reference Genome:</strong> ${afi.vcf_info.reference_genome}<br>
                        <strong>Sequencing Platform:</strong> ${afi.vcf_info.sequencing_platform}<br>
                        <strong>Sequencing Profile:</strong> ${afi.vcf_info.sequencing_profile}<br>
                        <strong>Sample Count:</strong> ${afi.vcf_info.sample_count}
                    `;
                }

                // Planned workflow (right column, top)
                const plannedContainer = document.getElementById('plannedWorkflowInfo');
                if (plannedContainer) {
                    plannedContainer.innerHTML = window.buildPlannedWorkflowHTML({ workflow: wf, fileType: (analysis.file_type || afi.file_type || '').toString() });
                }

                // Info alerts (left column, bottom)
                const infoContainer = document.getElementById('infoAlertsLeft');
                if (infoContainer) {
                    let infoHtml = '';
                    const recs = wf.recommendations || [];
                    if (recs.length > 0) {
                        infoHtml += `
                            <div class="alert alert-info">
                                <strong>Information:</strong>
                                <ul class="mb-0 mt-1">
                                    ${recs.map(r => `<li>${r}</li>`).join('')}
                                </ul>
                            </div>`;
                    }
                    // Validation errors appear as danger under info
                    if (afi.validation_errors && Array.isArray(afi.validation_errors) && afi.validation_errors.length > 0) {
                        infoHtml += `
                            <div class="alert alert-danger mt-2">
                                <strong>Validation Errors:</strong>
                                <ul class="mb-0 mt-1">
                                    ${afi.validation_errors.map(e => `<li>${e}</li>`).join('')}
                                </ul>
                            </div>`;
                    }
                    infoContainer.innerHTML = infoHtml;
                }

                // Warnings (right column, bottom) and unsupported as danger
                const warns = wf.warnings || [];
                if (warnings) {
                    let warnHtml = '';
                    if (warns.length > 0) {
                        warnHtml += `
                            <strong>Warnings:</strong>
                            <ul class="mb-0 mt-1">
                                ${warns.map(w => `<li>${w}</li>`).join('')}
                            </ul>`;
                    }
                    if (wf.unsupported) {
                        warnHtml += `
                            <div class="alert alert-danger mt-2 mb-0">
                                <strong>Unsupported:</strong> ${wf.unsupported_reason || 'Unknown reason'}
                            </div>`;
                    }
                    if (warnHtml) {
                        warnings.classList.remove('d-none');
                        warnings.classList.add('alert');
                        warnings.classList.add('alert-warning');
                        warnings.innerHTML = warnHtml;
                    } else {
                        warnings.classList.add('d-none');
                        warnings.innerHTML = '';
                    }
                }

                // Hide upload progress bar when workflow monitoring starts
                if (window.uploadProgressManager && typeof window.uploadProgressManager.hideUploadProgress === 'function') {
                    window.uploadProgressManager.hideUploadProgress();
                }

                // Show progress container
                progressContainer.classList.remove('d-none');
                
                // Show cancel button
                const cancelButton = document.getElementById('cancelButton');
                if (cancelButton) {
                    cancelButton.classList.remove('d-none');
                }
                
                // Set analysis stage to blue (completed) when header data is received and displayed
                if (window.GlyphManager) {
                    window.GlyphManager.setStageState(document.getElementById('stageAnalysis'), 'completed');
                }
            };

            // Smooth Progress Bar Manager
            class SmoothProgressManager {
                constructor(progressBar, progressStatus) {
                    this.progressBar = progressBar;
                    this.progressStatus = progressStatus;
                    this.currentProgress = 0;
                    this.targetProgress = 0;
                    this.currentStage = null;
                    this.stageStartTime = null;
                    this.minStageDuration = 1500; // 1.5 second minimum per stage
                    this.animationDuration = 1000; // 1 second for progress bar animation
                    this.animationId = null;
                    this.isAnimating = false;
                    // No throttling needed - progress only increases and animation is already frame-rate limited
                    this.pendingStageUpdate = null; // Queue for pending stage updates
                    
                    // Stage simulation properties
                    this.isSimulating = false;
                    this.simulationId = null;
                    this.simulationStartTime = null;
                    this.simulationStartProgress = 0;
                    this.simulationTargetProgress = 0;
                    this.simulationStage = null;
                    this.simulationIsSkipped = false;
                    
                    // Stage definitions with progress ranges and simulation settings
                    this.stageDefinitions = {
                        'analysis': { min: 1, max: 9, quickStage: true, simulationRatio: 0.5 }, // 1 sec : 2%
                        'gatk': { min: 10, max: 49, quickStage: false, simulationRatio: 0.2 }, // 1 sec : 5%
                        'hla': { min: 20, max: 34, quickStage: false, simulationRatio: 0.2 },
                        'pypgx': { min: 50, max: 74, quickStage: false, simulationRatio: 0.2 },
                        'pharmcat': { min: 75, max: 89, quickStage: false, simulationRatio: 0.2 },
                        'report': { min: 90, max: 100, quickStage: true, simulationRatio: 0.5 } // 1 sec : 2%
                    };
                }

                updateProgress(targetProgress, stage, message) {
                    const now = Date.now();
                    
                    // Validate input parameters
                    if (targetProgress === undefined || targetProgress === null || isNaN(targetProgress)) {
                        console.warn(`Invalid progress value: ${targetProgress}, skipping update`);
                        return;
                    }
                    
                    // Stop any ongoing simulation
                    this.stopSimulation();
                    
                    // Check if we need to enforce minimum stage duration
                    if (this.currentStage && this.currentStage !== stage) {
                        const timeInCurrentStage = now - this.stageStartTime;
                        if (timeInCurrentStage < this.minStageDuration) {
                            // Still in minimum duration for current stage, queue the new stage update
                            const remainingTime = this.minStageDuration - timeInCurrentStage;
                            console.log(`Enforcing minimum stage duration: ${remainingTime}ms remaining for ${this.currentStage}, queuing ${stage}`);
                            
                            // Store the pending stage update
                            this.pendingStageUpdate = {
                                targetProgress,
                                stage,
                                message,
                                timestamp: now
                            };
                            
                            // Schedule the update after the remaining time
                            setTimeout(() => {
                                if (this.pendingStageUpdate) {
                                    const pending = this.pendingStageUpdate;
                                    this.pendingStageUpdate = null;
                                    this.updateProgress(pending.targetProgress, pending.stage, pending.message);
                                }
                            }, remainingTime);
                            return;
                        }
                    }

                    // Update stage if changed
                    if (this.currentStage !== stage) {
                        this.currentStage = stage;
                        this.stageStartTime = now;
                        console.log(`Stage changed to: ${stage}`);
                    }

                    // Update target progress
                    this.targetProgress = Math.max(0, Math.min(100, targetProgress));
                    
                    // Update status message immediately
                    if (this.progressStatus && message) {
                        this.progressStatus.textContent = message;
                    }

                    // Check if we should start stage simulation
                    if (this.shouldSimulateStage(stage, targetProgress)) {
                        this.startStageSimulation(stage, targetProgress, message);
                    } else {
                        // Start smooth animation if not already animating
                        if (!this.isAnimating) {
                            this.animateProgress();
                        }
                    }
                }

                animateProgress() {
                    if (this.isAnimating) return;
                    
                    this.isAnimating = true;
                    const startProgress = this.currentProgress;
                    const progressDiff = this.targetProgress - startProgress;
                    const startTime = Date.now();

                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / this.animationDuration, 1);
                        
                        // Use easing function for smooth animation
                        const easedProgress = this.easeInOutCubic(progress);
                        const currentValue = startProgress + (progressDiff * easedProgress);
                        
                        // Update progress bar
                        this.currentProgress = Math.round(currentValue);
                        this.progressBar.style.width = `${this.currentProgress}%`;
                        this.progressBar.textContent = `${this.currentProgress}%`;
                        this.progressBar.setAttribute('aria-valuenow', this.currentProgress);

                        if (progress < 1) {
                            this.animationId = requestAnimationFrame(animate);
                        } else {
                            // Animation complete
                            this.currentProgress = this.targetProgress;
                            this.isAnimating = false;
                            this.animationId = null;
                        }
                    };

                    this.animationId = requestAnimationFrame(animate);
                }

                easeInOutCubic(t) {
                    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                }

                // Stage simulation methods
                shouldSimulateStage(stage, targetProgress) {
                    const stageDef = this.stageDefinitions[stage];
                    if (!stageDef) return false;
                    
                    // Only simulate quick stages (analysis and report)
                    if (!stageDef.quickStage) return false;
                    
                    // Check if we're jumping to the stage's maximum progress
                    const progressJump = targetProgress - this.currentProgress;
                    const stageRange = stageDef.max - stageDef.min;
                    
                    // If we're jumping more than 50% of the stage range, simulate
                    return progressJump > (stageRange * 0.5);
                }

                startStageSimulation(stage, targetProgress, message) {
                    const stageDef = this.stageDefinitions[stage];
                    if (!stageDef) return;
                    
                    console.log(`Starting stage simulation for ${stage}: ${this.currentProgress}% -> ${targetProgress}%`);
                    
                    this.isSimulating = true;
                    this.simulationStartTime = Date.now();
                    this.simulationStartProgress = this.currentProgress;
                    this.simulationTargetProgress = targetProgress;
                    this.simulationStage = stage;
                    this.simulationIsSkipped = false;
                    
                    // Calculate simulation duration based on progress range and ratio
                    const progressRange = targetProgress - this.currentProgress;
                    const simulationDuration = Math.max(1000, progressRange / stageDef.simulationRatio * 1000); // Convert to milliseconds
                    
                    console.log(`Simulation duration: ${simulationDuration}ms for ${progressRange}% progress`);
                    
                    this.animateStageSimulation(simulationDuration, message);
                }

                animateStageSimulation(duration, message) {
                    if (!this.isSimulating) return;
                    
                    const startTime = Date.now();
                    const startProgress = this.simulationStartProgress;
                    const progressDiff = this.simulationTargetProgress - startProgress;
                    
                    const animate = () => {
                        if (!this.isSimulating) return;
                        
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Use cubic easing for smooth simulation
                        const easedProgress = this.easeInOutCubic(progress);
                        const currentValue = startProgress + (progressDiff * easedProgress);
                        
                        // Update progress bar
                        this.currentProgress = Math.round(currentValue);
                        this.progressBar.style.width = `${this.currentProgress}%`;
                        this.progressBar.textContent = `${this.currentProgress}%`;
                        this.progressBar.setAttribute('aria-valuenow', this.currentProgress);
                        
                        // Update status message
                        if (this.progressStatus && message) {
                            this.progressStatus.textContent = message;
                        }
                        
                        if (progress < 1) {
                            this.simulationId = requestAnimationFrame(animate);
                        } else {
                            // Simulation complete
                            this.currentProgress = this.simulationTargetProgress;
                            this.isSimulating = false;
                            this.simulationId = null;
                            console.log(`Stage simulation complete for ${this.simulationStage}`);
                        }
                    };
                    
                    this.simulationId = requestAnimationFrame(animate);
                }

                stopSimulation() {
                    if (this.isSimulating) {
                        console.log(`Stopping stage simulation for ${this.simulationStage}`);
                        this.isSimulating = false;
                        if (this.simulationId) {
                            cancelAnimationFrame(this.simulationId);
                            this.simulationId = null;
                        }
                    }
                }

                // Method to handle skipped stages
                simulateSkippedStage(skippedStage, fromProgress, toProgress) {
                    const stageDef = this.stageDefinitions[skippedStage];
                    if (!stageDef) return;
                    
                    console.log(`Simulating skipped stage ${skippedStage}: ${fromProgress}% -> ${toProgress}%`);
                    
                    this.isSimulating = true;
                    this.simulationStartTime = Date.now();
                    this.simulationStartProgress = fromProgress;
                    this.simulationTargetProgress = toProgress;
                    this.simulationStage = skippedStage;
                    this.simulationIsSkipped = true;
                    
                    // Calculate simulation duration for skipped stages (1 sec : 5%)
                    const progressRange = toProgress - fromProgress;
                    const simulationDuration = Math.max(500, progressRange / 0.2 * 1000); // 1 sec : 5%
                    
                    console.log(`Skipped stage simulation duration: ${simulationDuration}ms for ${progressRange}% progress`);
                    
                    this.animateStageSimulation(simulationDuration, `Skipping ${skippedStage} stage`);
                }

                // Helper method to detect and handle skipped stages
                detectAndSimulateSkippedStages(currentStage, currentProgress) {
                    const stageOrder = ['analysis', 'gatk', 'hla', 'pypgx', 'pharmcat', 'report'];
                    const currentStageIndex = stageOrder.indexOf(currentStage);
                    
                    if (currentStageIndex === -1) return;
                    
                    // Check for gaps in progress that might indicate skipped stages
                    for (let i = 0; i < currentStageIndex; i++) {
                        const stage = stageOrder[i];
                        const stageDef = this.stageDefinitions[stage];
                        if (!stageDef) continue;
                        
                        // Check if we've jumped over this stage's range
                        if (currentProgress > stageDef.max && this.currentProgress <= stageDef.min) {
                            console.log(`Detected potential skipped stage: ${stage}`);
                            // Don't simulate here - let the workflow system handle this
                            // This is just for detection and logging
                        }
                    }
                }

                // Public method to manually trigger skipped stage simulation
                simulateSkippedStages(skippedStages, fromProgress, toProgress) {
                    if (!Array.isArray(skippedStages) || skippedStages.length === 0) return;
                    
                    console.log(`Manually simulating skipped stages: ${skippedStages.join(', ')}`);
                    
                    // Calculate progress per stage
                    const totalProgressRange = toProgress - fromProgress;
                    const progressPerStage = totalProgressRange / skippedStages.length;
                    
                    let currentFromProgress = fromProgress;
                    
                    skippedStages.forEach((stage, index) => {
                        const stageToProgress = Math.min(
                            currentFromProgress + progressPerStage,
                            toProgress
                        );
                        
                        // Add a small delay between stages for visual effect
                        setTimeout(() => {
                            this.simulateSkippedStage(stage, currentFromProgress, stageToProgress);
                        }, index * 200); // 200ms delay between stages
                        
                        currentFromProgress = stageToProgress;
                    });
                }

                reset() {
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                    this.isAnimating = false;
                    this.currentProgress = 0;
                    this.targetProgress = 0;
                    this.currentStage = null;
                    this.stageStartTime = null;
                    
                    // Reset simulation state
                    this.stopSimulation();
                    this.isSimulating = false;
                    this.simulationId = null;
                    this.simulationStartTime = null;
                    this.simulationStartProgress = 0;
                    this.simulationTargetProgress = 0;
                    this.simulationStage = null;
                    this.simulationIsSkipped = false;
                    
                    this.progressBar.style.width = '0%';
                    this.progressBar.textContent = '0%';
                    this.progressBar.setAttribute('aria-valuenow', 0);
                    if (this.progressStatus) {
                        this.progressStatus.textContent = 'Preparing...';
                    }
                }

                // Method to stop progress bar animation (useful for completion)
                stopAnimation() {
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                    this.isAnimating = false;
                    this.stopSimulation();
                    
                    // Remove animation classes from progress bar
                    this.progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                }
            }

            // Global smooth progress manager instance
            window.globalSmoothProgress = null;
            
            // Initialize smooth progress manager
            window.initializeSmoothProgress = function() {
                if (!window.globalSmoothProgress) {
                    const progressBar = document.getElementById('progressBar');
                    const progressStatus = document.getElementById('progressStatus');
                    if (progressBar && progressStatus) {
                        window.globalSmoothProgress = new SmoothProgressManager(progressBar, progressStatus);
                    }
                }
                return window.globalSmoothProgress;
            }

            // Function to reset progress for new uploads
            window.resetProgress = function() {
                if (window.globalSmoothProgress) {
                    window.globalSmoothProgress.reset();
                }
            };

            // Update the file upload handler to work without auth token
            form.addEventListener('submit', async function(e) {
                // The actual upload is now handled by GenomeDownloadProgress.js
                // Prevent default just in case - for backup if the main handler fails
                e.preventDefault();
                return false;
            });

            // Function to show results
            window.showResults = function(data) {
                const resultsDiv = document.getElementById('analysisResults');
                if (!resultsDiv) {
                    console.error("Results container not found");
                    return;
                }

                console.log("Showing results with data:", data);

                // Make sure we have a data object
                if (!data) {
                    console.warn("No data provided to showResults");
                    data = {};
                }
                
                // Get job ID from upload response
                const jobId = data.job_id;
                if (!jobId) {
                    console.error("No job_id found in upload response");
                    return;
                }
                
                // Extract report URLs from upload response
                const reportUrls = {
                    'pdf_report_url': data.pdf_report_url,
                    'html_report_url': data.html_report_url,
                    'interactive_html_report_url': data.interactive_html_report_url,
                    'pharmcat_html_report_url': data.pharmcat_html_report_url,
                    'pharmcat_json_report_url': data.pharmcat_json_report_url,
                    'pharmcat_tsv_report_url': data.pharmcat_tsv_report_url
                };
                
                console.log("Report URLs:", reportUrls);

                let resultsHtml = `
                    <div class="alert alert-success">
                        <h4>Analysis Complete!</h4>
                        <p>The pharmacogenomic analysis has been completed successfully.</p>
                `;

                // Check if we found any report URLs
                if (Object.keys(reportUrls).length === 0) {
                    console.warn("No report URLs found in data:", data);
                    resultsHtml += `
                        <div class="mt-3 alert alert-warning">
                            <p>Report URLs not found in results data.</p>
                        </div>
                    `;
                }

                        // Group the reports by type for better organization
                        const reportGroups = [
                            {
                                title: "Custom Reports",
                                reports: [
                                    { key: 'pdf_report_url', label: 'View PDF Report', icon: 'bi-file-pdf', color: 'btn-primary' },
                                    { key: 'html_report_url', label: 'View Interactive HTML Report', icon: 'bi-file-code', color: 'btn-info' }
                                ]
                            },
                            {
                                title: "PharmCAT Reports",
                                reports: [
                                    { key: 'pharmcat_html_report_url', label: 'View PharmCAT HTML Report', icon: 'bi-file-medical', color: 'btn-success' },
                                    { key: 'pharmcat_json_report_url', label: 'View PharmCAT JSON Report', icon: 'bi-filetype-json', color: 'btn-warning' },
                                    { key: 'pharmcat_tsv_report_url', label: 'View PharmCAT TSV Report', icon: 'bi-filetype-csv', color: 'btn-secondary' }
                                ]
                            }
                        ];
                
                // Add report links by group
                reportGroups.forEach(group => {
                    // Check if there are any reports in this group
                    const availableReports = group.reports.filter(report => reportUrls[report.key]);
                    
                    if (availableReports.length > 0) {
                        resultsHtml += `
                            <div class="mt-3">
                                <h5>${group.title}</h5>
                        `;
                        
                        availableReports.forEach(report => {
                            resultsHtml += `
                                <div class="mt-2">
                                    <a href="${reportUrls[report.key]}" class="btn ${report.color}" target="_blank">
                                        <i class="bi ${report.icon}"></i> ${report.label}
                                    </a>
                                </div>
                            `;
                        });
                        
                        resultsHtml += `</div>`;
                    }
                });

                // Add download all reports button
                const patientId = data.data?.patient_id || data.patient_id || jobId;
                if (patientId) {
                    resultsHtml += `
                        <div class="mt-4">
                            <h5>Download All Reports</h5>
                            <div class="mt-2">
                                <button id="downloadAllBtn" class="btn btn-dark" onclick="downloadAllReports('${patientId}')">
                                    <i class="bi bi-download"></i> Download All Reports as ZIP
                                </button>
                            </div>
                        </div>
                    `;
                }

                resultsHtml += `</div>`;
                resultsDiv.innerHTML = resultsHtml;
                resultsDiv.classList.remove('d-none');
                
                // Log the completion in the log panel
                addLogMessage("Analysis complete! 5 reports are available: 2 custom Reports (PDF, Interactive HTML) and 3 PharmCAT reports (HTML, JSON, TSV).", "success");
            }

            // Function to show error
            function showError(message) {
                const resultsDiv = document.getElementById('analysisResults');
                if (!resultsDiv) {
                    console.error("Results container not found");
                    return;
                }
                
                resultsDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <h4>Analysis Failed</h4>
                        <p>${message}</p>
                    </div>
                `;
                resultsDiv.classList.remove('d-none');
            }

            // Function to show login form
            function showLoginForm() {
                mainContent.classList.add('d-none');
                loginForm.classList.remove('d-none');
            }
        });
        


        // Function to download and use PharmCAT example VCF for demo
        async function runPharmCatDemo() {
            try {
                // Show that we're fetching the demo file
                const logMessages = document.getElementById('logMessages');
                const progressContainer = document.getElementById('progressContainer');
                
                if (!logMessages || !progressContainer) {
                    console.error("Required elements not found");
                    return;
                }
                
                // Add to log
                window.addLogMessage("Loading PharmCAT example VCF file...", "info");

                // Hide upload progress bar when workflow monitoring starts
                if (window.uploadProgressManager && typeof window.uploadProgressManager.hideUploadProgress === 'function') {
                    window.uploadProgressManager.hideUploadProgress();
                }

                // Show progress container
                progressContainer.classList.remove('d-none');
                
                // Show cancel button
                const cancelButton = document.getElementById('cancelButton');
                if (cancelButton) {
                    cancelButton.classList.remove('d-none');
                }
                
                // Update progress status
                const progressStatus = document.getElementById('progressStatus');
                if (progressStatus) {
                    progressStatus.textContent = "Preparing PharmCAT example VCF...";
                }
                
                // Disable the upload button
                const uploadButton = document.getElementById('uploadButton');
                const demoButton = document.getElementById('demoButton');
                if (uploadButton) uploadButton.disabled = true;
                if (demoButton) demoButton.disabled = true;
                
                // Instead of creating a VCF in memory, fetch the sample file
                // Add cache-busting parameter to ensure we get the latest version
                const response = await fetch(`/static/demo/pharmcat.example.vcf?t=${Date.now()}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch example VCF: ${response.status}`);
                }

                const vcfContent = await response.text();
                
                // Create a File object from the fetched VCF content
                const demoFile = new File([vcfContent], 'pharmcat-demo.vcf', { type: 'text/plain' });
                
                // Create FormData object just like a regular file upload
                const formData = new FormData();
                formData.append('files', demoFile);
                formData.append('sample_identifier', 'PharmCAT-Demo');
                
                // Add service toggle states to demo upload
                if (window.getStageToggleStates) {
                    const toggleStates = window.getStageToggleStates();
                    const serviceMapping = {
                        'hla': 'optitype_enabled',
                        'gatk': 'gatk_enabled', 
                        'pypgx': 'pypgx_enabled',
                        'report': 'report_enabled' // Custom report generation toggle
                    };
                    
                    Object.entries(serviceMapping).forEach(([stageName, serviceName]) => {
                        const enabled = toggleStates[stageName] || false;
                        formData.append(serviceName, enabled.toString());
                    });
                }
                
                // Mark this as a VCF file for consistent handling
                window.isVcfFile = true;
                
                // Start progress tracking
                if (window.GenomeDownloadProgress && window.GenomeDownloadProgress.startProgressTracking) {
                    window.GenomeDownloadProgress.startProgressTracking();
                }
                
                // Make the request to the same endpoint used for regular uploads
                const uploadResponse = await fetch('/upload/genomic-data', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Failed to upload demo file: ${uploadResponse.status}`);
                }
                
                const result = await uploadResponse.json();
                console.log("Demo upload result:", result);
                
                // Process the response just like a regular upload
                window.addLogMessage("Demo file uploaded successfully", "success");
                
                // Update file analysis display
                if (window.updateFileAnalysis) {
                    window.updateFileAnalysis(result);
                }
                
                // Start monitoring progress with a small delay to ensure workflow is created
                if (window.monitorProgress && result.job_id) {
                    console.log('Starting workflow monitoring in 1 second for job:', result.job_id);
                    setTimeout(() => {
                        window.monitorProgress(result.job_id);
                    }, 1000);
                }
                

                
            } catch (error) {
                console.error("Error running PharmCAT demo:", error);
                window.addLogMessage(`Error running demo: ${error.message}`, "danger");
                
                // Re-enable buttons
                const uploadButton = document.getElementById('uploadButton');
                const demoButton = document.getElementById('demoButton');
                if (uploadButton) uploadButton.disabled = false;
                if (demoButton) demoButton.disabled = false;
                
                // Hide cancel button on error
                const cancelButton = document.getElementById('cancelButton');
                if (cancelButton) {
                    cancelButton.classList.add('d-none');
                }
            }
        }


        // Function to view/hide file header information
        async function viewHeader() {
            const fileInput = document.getElementById('genomicFile');
            const headerDisplay = document.getElementById('headerDisplay');
            const headerContent = document.getElementById('headerContent');
            const viewHeaderButton = document.getElementById('viewHeaderButton');
            const stageAnalysis = document.getElementById('stageAnalysis');

            // Check if header is currently visible and has content
            const isVisible = !headerDisplay.classList.contains('d-none');
            const hasContent = headerContent.innerHTML.trim() !== '<!-- Header content will be displayed here -->';

            // If visible and has content, hide it (toggle off)
            if (isVisible && hasContent) {
                headerDisplay.classList.add('d-none');
                viewHeaderButton.innerHTML = '<i class="bi bi-eye"></i> View Header';
                
                // Deactivate analysis stage when header is closed
                if (stageAnalysis) {
                    stageAnalysis.classList.remove('text-primary');
                    stageAnalysis.classList.add('text-muted');
                }
                return;
            }

            // Otherwise, show header (either first time or was hidden)
            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select a genomic file first.');
                return;
            }

            const file = fileInput.files[0];

            // Show loading state
            viewHeaderButton.disabled = true;
            viewHeaderButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Inspecting...';
            headerContent.innerHTML = '<div class="text-center"><div class="spinner-border text-info" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Analyzing file header...</p></div>';
            headerDisplay.classList.remove('d-none');

            try {
                // Create FormData with the selected file
                const formData = new FormData();
                formData.append('file', file);

                // Make the request to the header inspection endpoint
                const response = await fetch('/upload/inspect-header', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                if (result.status === 'success') {
                    // Map new schema to expected format
                    const rawData = result.header_info;
                    const compat = result.compat || {};
                    const headerInfo = {
                        filename: result.original_filename || (rawData.file_info ? rawData.file_info.path.split('/').pop() : 'Unknown'),
                        file_type: rawData.file_info ? rawData.file_info.format : 'Unknown',
                        file_size: rawData.file_info ? rawData.file_info.size : undefined,
                        is_compressed: rawData.file_info ? rawData.file_info.compressed : undefined,
                        has_index: rawData.file_info ? rawData.file_info.has_index : undefined,
                        // Use workflow recommendations from backend
                        workflow: compat.workflow || {
                            recommendations: [],
                            warnings: [],
                            unsupported: false,
                            unsupported_reason: null
                        },
                        // Extract VCF info from metadata and sequences
                        vcf_info: rawData.metadata ? {
                            reference_genome: rawData.metadata.reference_genome || 'Unknown',
                            reference_genome_file: rawData.metadata.reference_genome_path || null,
                            sequencing_platform: rawData.metadata.created_by || 'Unknown',
                            sequencing_profile: (function() {
                                // Prefer explicit platform/profile if present later; fallback to contig count
                                const seqCount = rawData.sequences ? rawData.sequences.length : 0;
                                if (seqCount > 50) return 'whole_genome_sequencing';
                                if (seqCount > 10) return 'whole_exome_sequencing';
                                if (seqCount > 0) return 'targeted_sequencing';
                                return 'unknown';
                            })(),
                            has_index: rawData.file_info ? rawData.file_info.has_index : false,
                            is_bgzipped: rawData.file_info ? rawData.file_info.compressed : false,
                            contigs: rawData.sequences ? rawData.sequences.map(seq => seq.name) : [],
                            contig_lengths: (rawData.sequences || []).reduce((acc, seq) => { if (seq && seq.name) acc[seq.name] = seq.length || null; return acc; }, {}),
                            sample_count: (function() {
                                if (Array.isArray(rawData.samples)) return rawData.samples.length;
                                if (rawData.sample) return 1;
                                return 0;
                            })(),
                            variant_count: (rawData.format_specific && typeof rawData.format_specific.variant_count === 'number') ? rawData.format_specific.variant_count : null,
                            sample_id: (function() {
                                if (Array.isArray(rawData.samples) && rawData.samples.length > 0) {
                                    return rawData.samples[0];
                                }
                                return rawData.sample || null;
                            })(),
                            version: rawData.metadata.version || null
                        } : null
                    };

                    // Build the header display HTML with flattened vertical layout
                    let html = `
                        <!-- File Information Section -->
                        <div class="mb-4">
                            <h6 class="card-title d-flex align-items-center mb-3">
                                <i class="bi bi-file-earmark-text me-2 text-primary"></i>
                                File Information
                            </h6>
                            <div class="row g-2">
                                <div class="col-sm-4"><strong class="text-muted">Filename:</strong></div>
                                <div class="col-sm-8"><span class="badge bg-secondary">${headerInfo.filename || 'Unknown'}</span></div>

                                <div class="col-sm-4"><strong class="text-muted">File Type:</strong></div>
                                <div class="col-sm-8"><span class="badge bg-info">${headerInfo.file_type ? headerInfo.file_type.toUpperCase() : 'UNKNOWN'}</span></div>

                                <div class="col-sm-4"><strong class="text-muted">File Size:</strong></div>
                                <div class="col-sm-8">${headerInfo.file_size ? (headerInfo.file_size / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown'}</div>

                                <div class="col-sm-4"><strong class="text-muted">Compressed:</strong></div>
                                <div class="col-sm-8">
                                    <span class="badge ${headerInfo.is_compressed !== undefined ? (headerInfo.is_compressed ? 'bg-success' : 'bg-warning') : 'bg-secondary'}">
                                        ${headerInfo.is_compressed !== undefined ? (headerInfo.is_compressed ? 'Yes' : 'No') : 'Unknown'}
                                    </span>
                                </div>

                                <div class="col-sm-4"><strong class="text-muted">Has Index:</strong></div>
                                <div class="col-sm-8">
                                    <span class="badge ${headerInfo.has_index !== undefined ? (headerInfo.has_index ? 'bg-success' : 'bg-danger') : 'bg-secondary'}">
                                        ${headerInfo.has_index !== undefined ? (headerInfo.has_index ? 'Yes' : 'No') : 'Unknown'}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <!-- VCF Header Details Section (will be populated if VCF) -->
                        <div id="vcfDetailsSection" class="mb-4" style="display: none;"></div>

                        <!-- Analysis Recommendations Section -->
                        <div class="mb-3">
                            <h6 class="card-title d-flex align-items-center mb-3">
                                <i class="bi bi-gear me-2 text-primary"></i>
                                Analysis Recommendations
                            </h6>
                            <div class="mb-3">
                    `;

                    // Add workflow recommendations (with safety checks)
                    if (headerInfo.workflow && headerInfo.workflow.recommendations && headerInfo.workflow.recommendations.length > 0) {
                        html += '<div class="alert alert-info"><ul class="mb-0 mt-0">';
                        headerInfo.workflow.recommendations.forEach(rec => {
                            html += `<li>${rec}</li>`;
                        });
                        html += '</ul></div>';
                    }

                    if (headerInfo.workflow && headerInfo.workflow.warnings && headerInfo.workflow.warnings.length > 0) {
                        html += '<div class="alert alert-warning"><strong>Warnings:</strong><ul class="mb-0 mt-2">';
                        headerInfo.workflow.warnings.forEach(warn => {
                            html += `<li>${warn}</li>`;
                        });
                        html += '</ul></div>';
                    }

                    if (headerInfo.workflow && headerInfo.workflow.unsupported) {
                        html += `<div class="alert alert-danger"><strong>Unsupported:</strong> ${headerInfo.workflow.unsupported_reason || 'Unknown reason'}</div>`;
                    }

                    html += `
                            </div>
                        </div>
                    `;

                    // Add planned workflow section to align with analysis panel
                    html += window.buildPlannedWorkflowHTML({ workflow: headerInfo.workflow || {}, fileType: (headerInfo.file_type || '').toString() });

                    // Add VCF-specific information if available (to dedicated section)
                    let vcfDetailsHtml = '';
                    if (headerInfo.vcf_info && typeof headerInfo.vcf_info === 'object') {
                        const vcf = headerInfo.vcf_info;

                        vcfDetailsHtml = `
                                        <hr class="my-3">
                                        <h6 class="d-flex align-items-center mb-3">
                                            <i class="bi bi-dna me-2 text-primary"></i>
                                            VCF Header Details
                                        </h6>
                                        <div class="row g-2">
                                            <div class="col-12">
                                                <div class="row g-2 mb-2">
                                                    <div class="col-sm-3"><strong class="text-muted small">Reference Genome:</strong></div>
                                                    <div class="col-sm-9"><span class="badge bg-primary">${vcf.reference_genome || 'Unknown'}</span></div>
                                                </div>
                                                <div class="row g-2 mb-3">
                                                    <div class="col-12"><strong class="text-muted small">Reference Genome File:</strong></div>
                                                    <div class="col-12"><small class="text-muted">${vcf.reference_genome_file || 'Not specified'}</small></div>
                                                </div>
                                                <div class="row g-2">
                                                    <div class="col-12"><strong class="text-muted small">Sequencing Platform:</strong></div>
                                                    <div class="col-12"><span class="badge bg-secondary">${vcf.sequencing_platform || 'Unknown'}</span></div>
                                                </div>
                                                <div class="row g-2 mt-1">
                                                    <div class="col-sm-3"><strong class="text-muted small">Sample Count:</strong></div>
                                                    <div class="col-sm-2"><span class="badge bg-success">${vcf.sample_count !== undefined ? vcf.sample_count : 'Unknown'}</span></div>
                                                    <div class="col-sm-3"><strong class="text-muted small">Sequencing Profile:</strong></div>
                                                    <div class="col-sm-4"><span class="badge bg-info">${vcf.sequencing_profile ? vcf.sequencing_profile.replace('_', ' ').toUpperCase() : 'UNKNOWN'}</span></div>
                                                </div>
                                                <div class="row g-2 mt-2">
                                                    <div class="col-sm-3"><strong class="text-muted small">Variant Count:</strong></div>
                                                    <div class="col-sm-2">${vcf.variant_count !== null && vcf.variant_count !== undefined ? vcf.variant_count : 'Not counted'}</div>

                                                    <div class="col-sm-2"><strong class="text-muted small">Sample ID:</strong></div>
                                                    <div class="col-sm-5"><small class="text-muted">${vcf.sample_id || 'Not specified'}</small></div>
                                                </div>
                                                <div class="row g-2 mt-1">
                                                    <div class="col-sm-3"><strong class="text-muted small">Version:</strong></div>
                                                    <div class="col-sm-2"><span class="badge bg-info">${vcf.version || 'Unknown'}</span></div>

                                                    <div class="col-sm-2"><strong class="text-muted small">Total Contigs:</strong></div>
                                                    <div class="col-sm-5"><span class="badge bg-warning">${vcf.contigs ? vcf.contigs.length : 'Unknown'}</span></div>
                                                </div>
                                            </div>
                                        </div>
                        `;

                        if (vcf.contigs && vcf.contigs.length > 0) {
                            const sequences = rawData.sequences || [];
                            const canonicalOrder = [
                                'chr1','chr2','chr3','chr4','chr5','chr6','chr7','chr8','chr9','chr10','chr11','chr12',
                                'chr13','chr14','chr15','chr16','chr17','chr18','chr19','chr20','chr21','chr22','chrX','chrY','chrM'
                            ];
                            const orderMap = new Map(canonicalOrder.map((n, i) => [n, i]));
                            const canonicalSeqs = sequences
                                .filter(seq => seq && orderMap.has(seq.name))
                                .sort((a, b) => orderMap.get(a.name) - orderMap.get(b.name));
                            const items = canonicalSeqs.map(seq => `${seq.name}${seq.length ? ` (${(seq.length/1000000).toFixed(1)}Mb)` : ''}`);
                            vcfDetailsHtml += `
                                <div class="mt-3">
                                    <strong class="text-muted small">Sequence Details (canonical only):</strong>
                                    <div class="mt-2">
                                        <small class="text-muted">${items.join(', ')}</small>
                                    </div>
                                </div>
                            `;
                        }
                    }

                    // Close the main content
                    html += ``;

                    headerContent.innerHTML = html;

                    // Set analysis stage to green (running) when header analysis begins
                    if (window.GlyphManager) {
                        window.GlyphManager.setStageState(document.getElementById('stageAnalysis'), 'running');
                    }

                    // Add VCF details to the dedicated section
                    const vcfSection = document.getElementById('vcfDetailsSection');
                    if (vcfSection && vcfDetailsHtml) {
                        vcfSection.innerHTML = vcfDetailsHtml;
                        vcfSection.style.display = 'block';
                    }

                } else {
                    throw new Error(result.message || 'Failed to inspect header');
                }

            } catch (error) {
                console.error('Error inspecting header:', error);
                headerContent.innerHTML = `
                    <div class="alert alert-danger">
                        <h6><i class="bi bi-exclamation-triangle me-2"></i>Error Inspecting Header</h6>
                        <p class="mb-0">${error.message}</p>
                    </div>
                `;
            } finally {
                // Reset button state
                viewHeaderButton.disabled = false;
                viewHeaderButton.innerHTML = '<i class="bi bi-eye"></i> View Header';
            }
        }

        // Function to download all reports as a zip file
        function downloadAllReports(patientId) {
            if (!patientId) {
                console.error('No patient ID provided for download');
                addLogMessage('Error: No patient ID available for download', 'danger');
                return;
            }

            console.log('Starting download for patient ID:', patientId);
            
            // Show loading state
            const downloadBtn = document.getElementById('downloadAllBtn');
            if (downloadBtn) {
                downloadBtn.disabled = true;
                downloadBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Preparing Download...';
            }

            // Create download link
            const downloadUrl = `/upload/reports/download/${patientId}`;
            
            // Create a temporary link element and trigger download
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = `pgx_reports_${patientId}.zip`;
            link.style.display = 'none';
            
            // Add to DOM, click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Reset button state after a short delay
            setTimeout(() => {
                if (downloadBtn) {
                    downloadBtn.disabled = false;
                    downloadBtn.innerHTML = '<i class="bi bi-download"></i> Download All Reports as ZIP';
                }
            }, 2000);
            
            addLogMessage('Download started for all reports', 'success');
        }

        // Stage Popup and Toggle Functionality
        window.initializeStagePopups = function() {
            console.log('Initializing stage popups...');
            
            // Handle stage indicator clicks
            const stageIndicators = document.querySelectorAll('.stage-indicator');
            stageIndicators.forEach(indicator => {
                indicator.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Close any other open popups
                    document.querySelectorAll('.stage-popup').forEach(popup => {
                        if (popup !== this.querySelector('.stage-popup')) {
                            popup.style.display = 'none';
                        }
                    });
                    
                    // Toggle current popup
                    const popup = this.querySelector('.stage-popup');
                    if (popup) {
                        const isVisible = popup.style.display === 'block';
                        popup.style.display = isVisible ? 'none' : 'block';
                    }
                });
            });
            
            // Handle toggle button clicks
            const toggleButtons = document.querySelectorAll('.toggle-button');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const stage = this.getAttribute('data-stage');
                    const indicator = document.querySelector(`[data-stage="${stage}"]`);
                    const isEnabled = indicator.getAttribute('data-enabled') === 'true';
                    
                    // Toggle the state
                    const newState = !isEnabled;
                    indicator.setAttribute('data-enabled', newState.toString());
                    
                    // Update visual state
                    if (newState) {
                        indicator.classList.remove('disabled');
                        this.classList.remove('disabled');
                        this.classList.add('enabled');
                        this.textContent = '✓ Enabled';
                    } else {
                        indicator.classList.add('disabled');
                        this.classList.remove('enabled');
                        this.classList.add('disabled');
                        this.textContent = '✗ Disabled';
                    }
                    
                    console.log(`Stage ${stage} ${newState ? 'enabled' : 'disabled'}`);
                });
            });
            
            // Close popups when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.stage-indicator')) {
                    document.querySelectorAll('.stage-popup').forEach(popup => {
                        popup.style.display = 'none';
                    });
                }
            });
        };

        // Initialize service toggles from backend configuration
        window.initializeServiceToggles = async function() {
            console.log('Initializing service toggles from backend configuration...');
            
            try {
                // Fetch service configuration from backend
                const response = await fetch('/services-config');
                if (!response.ok) {
                    console.warn('Failed to fetch service configuration, using defaults');
                    return;
                }
                
                const config = await response.json();
                console.log('Service configuration:', config);
                
                // Map backend service names to UI stage names
                const serviceMapping = {
                    'optitype': 'hla',
                    'gatk': 'gatk',
                    'pypgx': 'pypgx',
                    'kroki': 'report'  // Needs to be changed, kroki is not synonymous with report
                };
                
                // Update UI toggles based on backend configuration
                Object.entries(serviceMapping).forEach(([serviceName, stageName]) => {
                    const serviceConfig = config.services[serviceName];
                    if (serviceConfig) {
                        const enabled = serviceConfig.enabled;
                        const indicator = document.querySelector(`[data-stage="${stageName}"]`);
                        const button = indicator?.querySelector('.toggle-button');
                        
                        if (indicator && button) {
                            // Update data attribute
                            indicator.setAttribute('data-enabled', enabled.toString());
                            
                            // Update visual state
                            if (enabled) {
                                indicator.classList.remove('disabled');
                                button.classList.remove('disabled');
                                button.classList.add('enabled');
                                button.textContent = '✓ Enabled';
                            } else {
                                indicator.classList.add('disabled');
                                button.classList.remove('enabled');
                                button.classList.add('disabled');
                                button.textContent = '✗ Disabled';
                            }
                            
                            console.log(`Initialized ${stageName} (${serviceName}): ${enabled ? 'enabled' : 'disabled'}`);
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error initializing service toggles:', error);
            }
        };

        // Get current stage toggle states for backend submission
        window.getStageToggleStates = function() {
            const states = {};
            const stageIndicators = document.querySelectorAll('.stage-indicator[data-toggleable="true"]');
            
            stageIndicators.forEach(indicator => {
                const stage = indicator.getAttribute('data-stage');
                const enabled = indicator.getAttribute('data-enabled') === 'true';
                states[stage] = enabled;
            });
            
            return states;
        };

        // Workflow Monitoring Integration
        let workflowMonitor = null;
        
        // Simplified Stage Management System - Uses Bootstrap classes
        window.GlyphManager = {
            // Track completed stages to preserve their state
            completedStages: new Set(),
            
            // Map workflow stages to stage indicators
            stepMapping: {
                'file_upload': 'stageUpload',
                'header_analysis': 'stageAnalysis',
                'hla_typing': 'stageHLA',
                'gatk': 'stageGATK',
                'gatk_processing': 'stageGATK',
                'gatk_cram_sam_to_bam': 'stageGATK',  // GATK CRAM/SAM→BAM conversion
                'gatk_alignment': 'stageGATK',        // GATK FASTQ→BAM alignment
                'pypgx_analysis': 'stagePyPGx',
                'pypgx_bam2vcf': 'stagePyPGx',       // Both PyPGx steps map to the same stage
                'pharmcat_analysis': 'stagePharmcat',
                'diagram_generation': 'stageReport',  // Report diagram generation
                'report_generation': 'stageReport',
                'completed': 'stageReport'
            },
            
            // Bootstrap classes for different states
            stateClasses: {
                'default': 'text-muted',
                'pending': 'text-info', 
                'running': 'text-success',
                'failed': 'text-danger',
                'completed': 'text-primary',
                'disabled': 'text-muted disabled'
            },
            
            /**
             * Set a stage indicator to a specific state using Bootstrap classes
             */
            setStageState: function(stageElement, state) {
                if (!stageElement) {
                    console.warn('Invalid stage element:', stageElement);
                    return;
                }
                
                // Track completed stages
                if (state === 'completed') {
                    this.completedStages.add(stageElement.id);
                } else if (state === 'default' || state === 'pending' || state === 'failed' || state === 'disabled') {
                    // Remove from completed set only for non-running states
                    this.completedStages.delete(stageElement.id);
                }
                
                // Remove all state classes
                Object.values(this.stateClasses).forEach(className => {
                    const classes = className.split(' ');
                    classes.forEach(cls => stageElement.classList.remove(cls));
                });
                
                // Special handling for Report stage - use green for completed state
                let newClasses;
                if (state === 'completed' && stageElement.id === 'stageReport') {
                    newClasses = 'text-success'; // Green for Report completion
                } else {
                    newClasses = this.stateClasses[state] || 'text-muted';
                }
                
                const classes = newClasses.split(' ');
                classes.forEach(cls => stageElement.classList.add(cls));
                
                console.log('Set stage state:', stageElement.id, '->', state, '(classes:', newClasses, ')');
            },
            
            /**
             * Reset all stages to default state, but preserve completed stages
             */
            resetAllStages: function() {
                console.log('Resetting all stages, preserving completed:', Array.from(this.completedStages));
                Object.values(this.stepMapping).forEach(stageId => {
                    const stage = document.getElementById(stageId);
                    if (stage) {
                        // Check if this stage is completed
                        const isCompleted = this.completedStages.has(stageId);
                        
                        if (isCompleted) {
                            console.log(`Preserving completed state for ${stageId}`);
                            this.setStageState(stage, 'completed');
                        } else {
                            this.setStageState(stage, 'default');
                        }
                    }
                });
            },
            
            /**
             * Update stage indicators based on workflow progress
             */
            updateStageIndicators: function(currentStep, status) {
                console.log('updateStageIndicators called with:', currentStep, status);
                console.log('Current completed stages before update:', Array.from(this.completedStages));
                
                // Reset all stages to default (but preserve completed stages)
                this.resetAllStages();
                
                // Highlight current step
                if (currentStep) {
                    const currentStepLower = currentStep.toLowerCase();
                    console.log('Looking for step:', currentStepLower, 'in mapping:', Object.keys(this.stepMapping));
                    
                    // Try exact match first
                    let found = false;
                    for (const [stepName, stageId] of Object.entries(this.stepMapping)) {
                        if (currentStepLower === stepName) {
                            console.log('Found exact match:', stepName, '->', stageId);
                            const stage = document.getElementById(stageId);
                            if (stage) {
                                this.setStageState(stage, this.mapStatusToState(status));
                                console.log('Updated stage element:', stageId, 'with status:', status);
                                
                                // Special logging for PyPGx stages
                                if (stageId === 'stagePyPGx') {
                                    console.log('PyPGx stage updated - completed stages:', Array.from(this.completedStages));
                                }
                                
                                found = true;
                            } else {
                                console.warn('Stage element not found:', stageId);
                            }
                            break;
                        }
                    }
                    
                    // If no exact match, try partial match
                    if (!found) {
                        for (const [stepName, stageId] of Object.entries(this.stepMapping)) {
                            if (currentStepLower.includes(stepName)) {
                                console.log('Found partial match:', stepName, '->', stageId);
                                const stage = document.getElementById(stageId);
                                if (stage) {
                                    this.setStageState(stage, this.mapStatusToState(status));
                                    console.log('Updated stage element:', stageId, 'with status:', status);
                                    found = true;
                                } else {
                                    console.warn('Stage element not found:', stageId);
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!found) {
                        console.warn('No matching step found for:', currentStepLower);
                    }
                }
            },
            
            /**
             * Map workflow status to Bootstrap state
             */
            mapStatusToState: function(status) {
                switch (status) {
                    case 'pending':
                        return 'pending';
                    case 'running':
                        return 'running';
                    case 'completed':
                        return 'completed';
                    case 'failed':
                    case 'error':
                        return 'failed';
                    case 'skipped':
                        return 'disabled';
                    case 'disabled':
                        return 'disabled';
                    default:
                        return 'default';
                }
            },
            
            /**
             * Special handling for PyPGx completion
             * CHECK: IS THIS REALLY NECESSARY?
             */
            handlePyPGxCompletion: function() {
                console.log('Handling PyPGx completion - setting stage to completed');
                const pypgxStage = document.getElementById('stagePyPGx');
                if (pypgxStage) {
                    this.setStageState(pypgxStage, 'completed');
                    console.log('PyPGx stage set to completed');
                }
            },
            
            /**
             * Clear all completed stages (for new workflow)
             */
            clearCompletedStages: function() {
                this.completedStages.clear();
                console.log('Cleared completed stages for new workflow');
            },
            
            /**
             * Set connection state for visual feedback
             */
            setConnectionState: function(connected) {
                console.log('Setting connection state:', connected);
                
                // Add or remove a connection indicator class to all stage indicators
                const stageIndicators = document.querySelectorAll('.stage-indicator');
                stageIndicators.forEach(indicator => {
                    if (connected) {
                        indicator.classList.remove('connection-lost');
                    } else {
                        indicator.classList.add('connection-lost');
                    }
                });
            }
        };

        // Enhanced progress monitoring that integrates with new workflow system
        window.monitorProgress = function(jobId) {
            console.log('Starting workflow monitoring for job:', jobId);
            
            // Don't clear completed stages - we want to preserve upload/analysis completion
            // window.GlyphManager.clearCompletedStages();
            
            // Validate jobId
            if (!jobId) {
                console.error('No job ID provided for monitoring');
                window.addLogMessage('Error: No job ID provided for monitoring', 'danger');
                return;
            }
            
            // Stop any existing workflow monitoring
            if (workflowMonitor) {
                console.log('Disconnecting existing workflow monitor');
                workflowMonitor.disconnect();
            }
            
            // Hide upload progress bar when workflow monitoring starts
            if (window.uploadProgressManager && typeof window.uploadProgressManager.hideUploadProgress === 'function') {
                window.uploadProgressManager.hideUploadProgress();
            }
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.classList.remove('d-none');
            }
            
            // Show cancel button
            const cancelButton = document.getElementById('cancelButton');
            if (cancelButton) {
                cancelButton.classList.remove('d-none');
            }
            
            // Initialize smooth progress manager
            const smoothProgress = window.initializeSmoothProgress();
            
            // Start workflow monitoring using the new system
            console.log('WorkflowMonitor available:', typeof WorkflowMonitor !== 'undefined');
            console.log('WorkflowMonitor class:', WorkflowMonitor);
            
            if (typeof WorkflowMonitor !== 'undefined') {
                console.log('Creating new WorkflowMonitor instance for jobId:', jobId);
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/v1/workflows/${jobId}/ws`;
                console.log('WebSocket URL will be:', wsUrl);
                
                try {
                    workflowMonitor = new WorkflowMonitor(jobId, {
                        baseUrl: window.location.origin,
                    onProgress: (progress, data) => {
                        console.log('Workflow progress received:', progress, data);
                        console.log('Progress data:', {
                            progress_percentage: data.progress_percentage,
                            current_step: data.current_step,
                            message: data.message,
                            status: data.status
                        });
                        
                        
                        // Use progress data directly from the API (no local calculation)
                        if (smoothProgress) {
                            const progressValue = data.progress_percentage || data.progress || progress;
                            const currentStep = data.current_step || 'Processing';
                            const message = data.message || data.status_message || 'Processing...';
                            
                            console.log(`Updating progress: ${progressValue}% - ${currentStep} - ${message}`);
                            smoothProgress.updateProgress(progressValue, currentStep, message);
                        }
                        
                        // Update stage indicators using simple glyph system
                        window.GlyphManager.updateStageIndicators(data.current_step || 'Processing', data.status || 'running');
                        
                    },
                    onComplete: (data) => {
                        console.log('Workflow completed:', data);
                        
                        
                        // Use completion data directly from the API
                        if (smoothProgress) {
                            smoothProgress.updateProgress(100, 'completed', 'Analysis complete!');
                            // Stop progress bar animation at 100%
                            smoothProgress.stopAnimation();
                        }
                        
                        // Update stage indicators using simple glyph system
                        window.GlyphManager.updateStageIndicators('completed', 'completed');
                        window.addLogMessage('Workflow completed successfully', 'success');
                        
                        // Hide cancel button on completion
                        const cancelButton = document.getElementById('cancelButton');
                        if (cancelButton) {
                            cancelButton.classList.add('d-none');
                        }
                        
                        // Show results window with completion data (now includes report URLs)
                        if (data && data.workflow_id) {
                            console.log('Showing results for completed workflow:', data.workflow_id);
                            console.log('Report URLs in completion data:', {
                                pdf: data.pdf_report_url,
                                html: data.html_report_url,
                                pharmcat_html: data.pharmcat_html_report_url,
                                pharmcat_json: data.pharmcat_json_report_url,
                                pharmcat_tsv: data.pharmcat_tsv_report_url
                            });
                            
                            // Create a data object that matches what showResults expects
                            const resultsData = {
                                job_id: data.workflow_id,
                                patient_id: data.patient_id,
                                pdf_report_url: data.pdf_report_url,
                                html_report_url: data.html_report_url,
                                interactive_html_report_url: data.interactive_html_report_url,
                                pharmcat_html_report_url: data.pharmcat_html_report_url,
                                pharmcat_json_report_url: data.pharmcat_json_report_url,
                                pharmcat_tsv_report_url: data.pharmcat_tsv_report_url
                            };
                            
                            // Call the existing showResults function
                            window.showResults(resultsData);
                        } else {
                            console.warn('No workflow data available for showing results');
                        }
                    },
                    onError: (error) => {
                        console.error('Workflow error:', error);
                        
                        
                        // Update stage indicators using simple glyph system
                        window.GlyphManager.updateStageIndicators('Error', 'failed');
                        window.addLogMessage(`Workflow error: ${error.message}`, 'danger');
                        
                        // Hide cancel button on error
                        const cancelButton = document.getElementById('cancelButton');
                        if (cancelButton) {
                            cancelButton.classList.add('d-none');
                        }
                    },
                    onStepUpdate: (data) => {
                        console.log('Step update received:', data);
                        console.log('Step name:', data.step_name, 'Status:', data.status);
                        
                        
                        // Update stage indicators using simple glyph system
                        window.GlyphManager.updateStageIndicators(data.step_name, data.status);
                        window.addLogMessage(`Step ${data.step_name}: ${data.status}`, 'info');
                        
                        // Also add more detailed step information to the log
                        if (data.container_name) {
                            window.addLogMessage(`  Container: ${data.container_name}`, 'info');
                        }
                        if (data.duration_seconds) {
                            window.addLogMessage(`  Duration: ${data.duration_seconds}s`, 'info');
                        }
                    },
                    onLogUpdate: (data) => {
                        console.log('Log update:', data);
                        
                        
                        // Map log levels to Bootstrap alert classes
                        const levelMap = {
                            'debug': 'info',
                            'info': 'info', 
                            'warning': 'warning',
                            'warn': 'warning',
                            'error': 'danger',
                            'critical': 'danger'
                        };
                        const alertClass = levelMap[data.log_level] || 'info';
                        window.addLogMessage(data.message, alertClass);
                    },
                    onReconnect: (attempts) => {
                        console.log(`Reconnection attempt ${attempts}`);
                        window.addLogMessage(`Reconnecting to workflow... (attempt ${attempts})`, 'warning');
                        
                        // Update glyph state manager - we're disconnected
                        window.GlyphManager.setConnectionState(false);
                    }
                });
                console.log('WorkflowMonitor created successfully');
                
                // Set up connection state management
                workflowMonitor.websocket.addEventListener('open', () => {
                    console.log('WebSocket connected, updating glyph state manager');
                    window.GlyphManager.setConnectionState(true);
                });
                
                workflowMonitor.websocket.addEventListener('close', () => {
                    console.log('WebSocket disconnected, updating glyph state manager');
                    window.GlyphManager.setConnectionState(false);
                });
                
                workflowMonitor.websocket.addEventListener('error', () => {
                    console.log('WebSocket error, updating glyph state manager');
                    window.GlyphManager.setConnectionState(false);
                });
            } catch (error) {
                console.error('Error creating WorkflowMonitor:', error);
                window.addLogMessage(`Error starting workflow monitoring: ${error.message}`, 'danger');
                return;
            }
            } else {
                console.error('WorkflowMonitor class not available, falling back to basic progress tracking');
                window.addLogMessage('Warning: Advanced monitoring not available, using basic tracking', 'warning');
                // Fallback to basic progress tracking
                if (smoothProgress) {
                    smoothProgress.updateProgress(0, 'Starting', 'Initializing analysis...');
                }
            }
            
            // Add log message
            window.addLogMessage('Workflow monitoring started', 'info');
        };
        
        // Function to animate progress bar reverse during cancellation
        window.animateProgressBarReverse = function(progressBar, progressContainer) {
            return new Promise((resolve) => {
                // Add cancellation class to stop stripe animation and change color
                progressBar.classList.add('progress-bar-cancelling');
                
                // Animate progress bar to 0% over 2 seconds
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressBar.setAttribute('aria-valuenow', 0);
                
                // After 2 seconds, hide the progress container
                setTimeout(() => {
                    progressContainer.classList.add('progress-container-cancelling');
                    // Wait for fade transition to complete, then hide completely
                    setTimeout(() => {
                        progressContainer.classList.add('d-none');
                        progressContainer.classList.remove('progress-container-cancelling');
                        progressBar.classList.remove('progress-bar-cancelling');
                        resolve();
                    }, 500); // 0.5s fade duration
                }, 2000); // 2s reverse animation duration
            });
        };
        
        // Function to update stage indicators during cancellation
        window.updateStageIndicatorsForCancellation = function() {
            // Find the currently active stage (the one with text-primary class)
            const activeStage = document.querySelector('.stage-indicator.text-primary');
            
            // Make active stage red and stop pulsing
            if (activeStage) {
                activeStage.classList.remove('text-primary');
                activeStage.classList.add('stage-indicator-cancelling-active');
            }
            
            // Make analyze stage green and keep pulsing
            const analyzeStage = document.getElementById('stageAnalysis');
            if (analyzeStage) {
                analyzeStage.classList.remove('text-muted');
                analyzeStage.classList.add('stage-indicator-cancelling-analyze');
            }
            
            // After 3 seconds, reset all stages to muted
            setTimeout(() => {
                if (activeStage) {
                    activeStage.classList.remove('stage-indicator-cancelling-active');
                    activeStage.classList.add('text-muted');
                }
                if (analyzeStage) {
                    analyzeStage.classList.remove('stage-indicator-cancelling-analyze');
                    analyzeStage.classList.add('text-muted');
                }
            }, 3000);
        };
        
        // Function to cancel job monitoring
        window.cancelJobMonitoring = async function() {
            console.log('Cancelling job monitoring...');
            
            // Get current workflow ID
            const currentWorkflowId = workflowMonitor ? workflowMonitor.workflowId : null;
            
            // Start visual feedback immediately
            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.getElementById('progressContainer');
            
            if (progressBar && progressContainer) {
                // Update stage indicators for cancellation visual feedback
                window.updateStageIndicatorsForCancellation();
                
                // Start progress bar reverse animation
                await window.animateProgressBarReverse(progressBar, progressContainer);
            }
            
            // Disconnect workflow monitor
            if (workflowMonitor) {
                workflowMonitor.disconnect();
                workflowMonitor = null;
            }
            
            // Cancel workflow on backend if we have a workflow ID
            if (currentWorkflowId) {
                try {
                    const response = await fetch(`/api/v1/workflows/${currentWorkflowId}/cancel`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        window.addLogMessage('Workflow cancelled on server', 'warning');
                    } else {
                        window.addLogMessage('Failed to cancel workflow on server', 'danger');
                    }
                } catch (error) {
                    console.error('Error cancelling workflow:', error);
                    window.addLogMessage('Error cancelling workflow: ' + error.message, 'danger');
                }
            }
            
            // Hide cancel button
            const cancelButton = document.getElementById('cancelButton');
            if (cancelButton) {
                cancelButton.classList.add('d-none');
            }
            
            // Reset stage glyphs (this will be handled by the visual feedback timeout)
            // The visual feedback function already handles resetting stages after 3 seconds
            
            // Reset progress
            if (window.globalSmoothProgress) {
                window.globalSmoothProgress.reset();
            }
            
            // Re-enable upload button
            const uploadButton = document.getElementById('uploadButton');
            if (uploadButton) {
                uploadButton.disabled = false;
            }
            
            window.addLogMessage('Job monitoring cancelled', 'warning');
        };
        
        // Initialize stage popups when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing stage popups...');
            window.initializeStagePopups();
            window.initializeServiceToggles();
        });
    </script>
</body>
</html>
